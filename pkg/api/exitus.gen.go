// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

const (
	OpenIdScopes = "OpenId.Scopes"
)

// Comment response.
type Comment struct {
	// User response.
	Author User `json:"author"`

	// The content associated with the Comment.
	Content string `json:"content"`

	// The timestamp the Comment was created.
	CreatedAt time.Time `json:"created_at"`

	// Comment identifier.
	Id string `json:"id"`

	// The timestamp the Comment was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// Comments page response.
type CommentsPage struct {
	Comments []Comment `json:"comments"`
}

// Customer response.
type Customer struct {
	// The timestamp the customer was created
	CreatedAt time.Time `json:"created_at"`

	// A description of the customer, with some background.
	Description *string `json:"description,omitempty"`

	// Customer identifier.
	Id string `json:"id"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the customer.
	Name string `json:"name"`

	// The timestamp the customer was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// Customer page response.
type CustomersPage struct {
	Customers []Customer `json:"customers"`
}

// Issue response.
type Issue struct {
	// User response.
	Assignee *User `json:"assignee,omitempty"`

	// The category of the Issue.
	Category string `json:"category"`

	// Comments page response.
	Comments *CommentsPage `json:"comments,omitempty"`

	// The content associated with the Issue, any background, or details required to help resolve it.
	Content *string `json:"content,omitempty"`

	// The timestamp the Issue was created
	CreatedAt time.Time `json:"created_at"`

	// Issue identifier.
	Id string `json:"id"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// User response.
	Reporter *User `json:"reporter,omitempty"`

	// The severity of the Issue.
	Severity string `json:"severity"`

	// The state of the Issue.
	State string `json:"state"`

	// A subject of the Issue.
	Subject string `json:"subject"`

	// The timestamp the Issue was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// Issue page response.
type IssuesPage struct {
	Issues []Issue `json:"issues"`
}

// New Comment request.
type NewComment struct {
	// The content associated with the comment.
	Content string `json:"content"`
}

// New Customer request.
type NewCustomer struct {
	// A description of the customer, with some background.
	Description *string `json:"description,omitempty"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the customer.
	Name string `json:"name"`
}

// New issue request.
type NewIssue struct {
	// A category of the Issue.
	Category string `json:"category"`

	// The content associated with the issue, any background, or details required to help resolve it.
	Content string `json:"content"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// A severity of the Issue.
	Severity string `json:"severity"`

	// A subject of the issue
	Subject string `json:"subject"`
}

// New Project request.
type NewProject struct {
	// A description of the project, with some background.
	Description *string `json:"description,omitempty"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the project.
	Name string `json:"name"`
}

// Project response.
type Project struct {
	// The timestamp the Project was created
	CreatedAt time.Time `json:"created_at"`

	// A description of the project, with some background.
	Description *string `json:"description,omitempty"`

	// Project identifier.
	Id string `json:"id"`

	// Labels assigned to an entity.
	Labels []string `json:"labels"`

	// The name of the Project.
	Name string `json:"name"`

	// The timestamp the Project was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// Project page response.
type ProjectsPage struct {
	Projects []Project `json:"projects"`
}

// UpdatedComment defines model for UpdatedComment.
type UpdatedComment struct {
	// Embedded struct due to allOf(#/components/schemas/NewComment)
	NewComment `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedCustomer defines model for UpdatedCustomer.
type UpdatedCustomer struct {
	// Embedded struct due to allOf(#/components/schemas/NewCustomer)
	NewCustomer `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedIssue defines model for UpdatedIssue.
type UpdatedIssue struct {
	// Embedded struct due to allOf(#/components/schemas/NewIssue)
	NewIssue `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedProject defines model for UpdatedProject.
type UpdatedProject struct {
	// Embedded struct due to allOf(#/components/schemas/NewProject)
	NewProject `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// User response.
type User struct {
	// The timestamp the User was created.
	CreatedAt time.Time `json:"created_at"`

	// Email of the User.
	Email string `json:"email"`

	// User identifier.
	Id string `json:"id"`

	// Name of the User.
	Name string `json:"name"`

	// The timestamp the User was last updated.
	UpdatedAt time.Time `json:"updated_at"`
}

// User page response.
type UsersPage struct {
	Users []User `json:"users"`
}

// Limit defines model for limit.
type Limit int64

// Offset defines model for offset.
type Offset int64

// Q defines model for q.
type Q string

// CustomersParams defines parameters for Customers.
type CustomersParams struct {
	// Used to query by name in a list operation.
	Q *Q `json:"q,omitempty"`

	// Used to request the next page in a list operation.
	Offset *Offset `json:"offset,omitempty"`

	// Used to specify the maximum number of records which are returned in the next page.
	Limit *Limit `json:"limit,omitempty"`
}

// NewCustomerJSONBody defines parameters for NewCustomer.
type NewCustomerJSONBody NewCustomer

// UpdateCustomerJSONBody defines parameters for UpdateCustomer.
type UpdateCustomerJSONBody UpdatedCustomer

// ProjectsParams defines parameters for Projects.
type ProjectsParams struct {
	// Used to query by name in a list operation.
	Q *Q `json:"q,omitempty"`

	// Used to request the next page in a list operation.
	Offset *Offset `json:"offset,omitempty"`

	// Used to specify the maximum number of records which are returned in the next page.
	Limit *Limit `json:"limit,omitempty"`
}

// NewProjectJSONBody defines parameters for NewProject.
type NewProjectJSONBody NewProject

// UpdateProjectJSONBody defines parameters for UpdateProject.
type UpdateProjectJSONBody UpdatedProject

// IssuesParams defines parameters for Issues.
type IssuesParams struct {
	// Used to query by name in a list operation.
	Q *Q `json:"q,omitempty"`

	// Used to request the next page in a list operation.
	Offset *Offset `json:"offset,omitempty"`

	// Used to specify the maximum number of records which are returned in the next page.
	Limit *Limit `json:"limit,omitempty"`
}

// NewIssueJSONBody defines parameters for NewIssue.
type NewIssueJSONBody NewIssue

// CommentsParams defines parameters for Comments.
type CommentsParams struct {
	// Used to query by name in a list operation.
	Q *Q `json:"q,omitempty"`

	// Used to request the next page in a list operation.
	Offset *Offset `json:"offset,omitempty"`

	// Used to specify the maximum number of records which are returned in the next page.
	Limit *Limit `json:"limit,omitempty"`
}

// NewCommentJSONBody defines parameters for NewComment.
type NewCommentJSONBody NewComment

// UsersParams defines parameters for Users.
type UsersParams struct {
	// Used to query by name in a list operation.
	Q *Q `json:"q,omitempty"`

	// Used to request the next page in a list operation.
	Offset *Offset `json:"offset,omitempty"`

	// Used to specify the maximum number of records which are returned in the next page.
	Limit *Limit `json:"limit,omitempty"`
}

// NewCustomerJSONRequestBody defines body for NewCustomer for application/json ContentType.
type NewCustomerJSONRequestBody NewCustomerJSONBody

// UpdateCustomerJSONRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdateCustomerJSONBody

// NewProjectJSONRequestBody defines body for NewProject for application/json ContentType.
type NewProjectJSONRequestBody NewProjectJSONBody

// UpdateProjectJSONRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdateProjectJSONBody

// NewIssueJSONRequestBody defines body for NewIssue for application/json ContentType.
type NewIssueJSONRequestBody NewIssueJSONBody

// NewCommentJSONRequestBody defines body for NewComment for application/json ContentType.
type NewCommentJSONRequestBody NewCommentJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Customers request
	Customers(ctx context.Context, params *CustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewCustomer request with any body
	NewCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewCustomer(ctx context.Context, body NewCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomer request
	GetCustomer(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomer request with any body
	UpdateCustomerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomer(ctx context.Context, id string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Projects request
	Projects(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewProject request with any body
	NewProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewProject(ctx context.Context, body NewProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateProject request with any body
	UpdateProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateProject(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Issues request
	Issues(ctx context.Context, projectId string, params *IssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewIssue request with any body
	NewIssueWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewIssue(ctx context.Context, projectId string, body NewIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIssue request
	GetIssue(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIssue request
	UpdateIssue(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Comments request
	Comments(ctx context.Context, projectId string, issueId string, params *CommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NewComment request with any body
	NewCommentWithBody(ctx context.Context, projectId string, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NewComment(ctx context.Context, projectId string, issueId string, body NewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateComment request
	UpdateComment(ctx context.Context, projectId string, issueId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Users request
	Users(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Customers(ctx context.Context, params *CustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewCustomerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewCustomer(ctx context.Context, body NewCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewCustomerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomer(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomer(ctx context.Context, id string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Projects(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewProjectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewProject(ctx context.Context, body NewProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Issues(ctx context.Context, projectId string, params *IssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIssuesRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewIssueWithBody(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewIssueRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewIssue(ctx context.Context, projectId string, body NewIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewIssueRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIssue(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIssueRequest(c.Server, projectId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIssue(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIssueRequest(c.Server, projectId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Comments(ctx context.Context, projectId string, issueId string, params *CommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommentsRequest(c.Server, projectId, issueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewCommentWithBody(ctx context.Context, projectId string, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewCommentRequestWithBody(c.Server, projectId, issueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NewComment(ctx context.Context, projectId string, issueId string, body NewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNewCommentRequest(c.Server, projectId, issueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComment(ctx context.Context, projectId string, issueId string, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCommentRequest(c.Server, projectId, issueId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Users(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCustomersRequest generates requests for Customers
func NewCustomersRequest(server string, params *CustomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Q != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewCustomerRequest calls the generic NewCustomer builder with application/json body
func NewNewCustomerRequest(server string, body NewCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewCustomerRequestWithBody(server, "application/json", bodyReader)
}

// NewNewCustomerRequestWithBody generates requests for NewCustomer with any type of body
func NewNewCustomerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomerRequest calls the generic UpdateCustomer builder with application/json body
func NewUpdateCustomerRequest(server string, id string, body UpdateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCustomerRequestWithBody generates requests for UpdateCustomer with any type of body
func NewUpdateCustomerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProjectsRequest generates requests for Projects
func NewProjectsRequest(server string, params *ProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Q != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewProjectRequest calls the generic NewProject builder with application/json body
func NewNewProjectRequest(server string, body NewProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewNewProjectRequestWithBody generates requests for NewProject with any type of body
func NewNewProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, id string, body UpdateProjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIssuesRequest generates requests for Issues
func NewIssuesRequest(server string, projectId string, params *IssuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Q != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewIssueRequest calls the generic NewIssue builder with application/json body
func NewNewIssueRequest(server string, projectId string, body NewIssueJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewIssueRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewNewIssueRequestWithBody generates requests for NewIssue with any type of body
func NewNewIssueRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIssueRequest generates requests for GetIssue
func NewGetIssueRequest(server string, projectId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIssueRequest generates requests for UpdateIssue
func NewUpdateIssueRequest(server string, projectId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommentsRequest generates requests for Comments
func NewCommentsRequest(server string, projectId string, issueId string, params *CommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues/%s/comments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Q != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewCommentRequest calls the generic NewComment builder with application/json body
func NewNewCommentRequest(server string, projectId string, issueId string, body NewCommentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewCommentRequestWithBody(server, projectId, issueId, "application/json", bodyReader)
}

// NewNewCommentRequestWithBody generates requests for NewComment with any type of body
func NewNewCommentRequestWithBody(server string, projectId string, issueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues/%s/comments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCommentRequest generates requests for UpdateComment
func NewUpdateCommentRequest(server string, projectId string, issueId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s/issues/%s/comments/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersRequest generates requests for Users
func NewUsersRequest(server string, params *UsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Q != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Offset != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// Customers request
	CustomersWithResponse(ctx context.Context, params *CustomersParams, reqEditors ...RequestEditorFn) (*CustomersResponse, error)

	// NewCustomer request with any body
	NewCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewCustomerResponse, error)

	NewCustomerWithResponse(ctx context.Context, body NewCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*NewCustomerResponse, error)

	// GetCustomer request
	GetCustomerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

	// UpdateCustomer request with any body
	UpdateCustomerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	UpdateCustomerWithResponse(ctx context.Context, id string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error)

	// Projects request
	ProjectsWithResponse(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*ProjectsResponse, error)

	// NewProject request with any body
	NewProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewProjectResponse, error)

	NewProjectWithResponse(ctx context.Context, body NewProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*NewProjectResponse, error)

	// GetProject request
	GetProjectWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// UpdateProject request with any body
	UpdateProjectWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	UpdateProjectWithResponse(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error)

	// Issues request
	IssuesWithResponse(ctx context.Context, projectId string, params *IssuesParams, reqEditors ...RequestEditorFn) (*IssuesResponse, error)

	// NewIssue request with any body
	NewIssueWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewIssueResponse, error)

	NewIssueWithResponse(ctx context.Context, projectId string, body NewIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*NewIssueResponse, error)

	// GetIssue request
	GetIssueWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*GetIssueResponse, error)

	// UpdateIssue request
	UpdateIssueWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*UpdateIssueResponse, error)

	// Comments request
	CommentsWithResponse(ctx context.Context, projectId string, issueId string, params *CommentsParams, reqEditors ...RequestEditorFn) (*CommentsResponse, error)

	// NewComment request with any body
	NewCommentWithBodyWithResponse(ctx context.Context, projectId string, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewCommentResponse, error)

	NewCommentWithResponse(ctx context.Context, projectId string, issueId string, body NewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*NewCommentResponse, error)

	// UpdateComment request
	UpdateCommentWithResponse(ctx context.Context, projectId string, issueId string, id string, reqEditors ...RequestEditorFn) (*UpdateCommentResponse, error)

	// Users request
	UsersWithResponse(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*UsersResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)
}

type CustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomersPage
}

// Status returns HTTPResponse.Status
func (r CustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Customer
}

// Status returns HTTPResponse.Status
func (r NewCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Customer
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Customer
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectsPage
}

// Status returns HTTPResponse.Status
func (r ProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
}

// Status returns HTTPResponse.Status
func (r NewProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
}

// Status returns HTTPResponse.Status
func (r UpdateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IssuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssuesPage
}

// Status returns HTTPResponse.Status
func (r IssuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IssuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Issue
}

// Status returns HTTPResponse.Status
func (r NewIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Issue
}

// Status returns HTTPResponse.Status
func (r GetIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatedIssue
}

// Status returns HTTPResponse.Status
func (r UpdateIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CommentsPage
}

// Status returns HTTPResponse.Status
func (r CommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NewCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Comment
}

// Status returns HTTPResponse.Status
func (r NewCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NewCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatedComment
}

// Status returns HTTPResponse.Status
func (r UpdateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersPage
}

// Status returns HTTPResponse.Status
func (r UsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CustomersWithResponse request returning *CustomersResponse
func (c *ClientWithResponses) CustomersWithResponse(ctx context.Context, params *CustomersParams, reqEditors ...RequestEditorFn) (*CustomersResponse, error) {
	rsp, err := c.Customers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCustomersResponse(rsp)
}

// NewCustomerWithBodyWithResponse request with arbitrary body returning *NewCustomerResponse
func (c *ClientWithResponses) NewCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewCustomerResponse, error) {
	rsp, err := c.NewCustomerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewCustomerResponse(rsp)
}

func (c *ClientWithResponses) NewCustomerWithResponse(ctx context.Context, body NewCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*NewCustomerResponse, error) {
	rsp, err := c.NewCustomer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewCustomerResponse(rsp)
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerResponse(rsp)
}

// UpdateCustomerWithBodyWithResponse request with arbitrary body returning *UpdateCustomerResponse
func (c *ClientWithResponses) UpdateCustomerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomerWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerWithResponse(ctx context.Context, id string, body UpdateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerResponse, error) {
	rsp, err := c.UpdateCustomer(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerResponse(rsp)
}

// ProjectsWithResponse request returning *ProjectsResponse
func (c *ClientWithResponses) ProjectsWithResponse(ctx context.Context, params *ProjectsParams, reqEditors ...RequestEditorFn) (*ProjectsResponse, error) {
	rsp, err := c.Projects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProjectsResponse(rsp)
}

// NewProjectWithBodyWithResponse request with arbitrary body returning *NewProjectResponse
func (c *ClientWithResponses) NewProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewProjectResponse, error) {
	rsp, err := c.NewProjectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewProjectResponse(rsp)
}

func (c *ClientWithResponses) NewProjectWithResponse(ctx context.Context, body NewProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*NewProjectResponse, error) {
	rsp, err := c.NewProject(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, id string, body UpdateProjectJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateProjectResponse(rsp)
}

// IssuesWithResponse request returning *IssuesResponse
func (c *ClientWithResponses) IssuesWithResponse(ctx context.Context, projectId string, params *IssuesParams, reqEditors ...RequestEditorFn) (*IssuesResponse, error) {
	rsp, err := c.Issues(ctx, projectId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIssuesResponse(rsp)
}

// NewIssueWithBodyWithResponse request with arbitrary body returning *NewIssueResponse
func (c *ClientWithResponses) NewIssueWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewIssueResponse, error) {
	rsp, err := c.NewIssueWithBody(ctx, projectId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewIssueResponse(rsp)
}

func (c *ClientWithResponses) NewIssueWithResponse(ctx context.Context, projectId string, body NewIssueJSONRequestBody, reqEditors ...RequestEditorFn) (*NewIssueResponse, error) {
	rsp, err := c.NewIssue(ctx, projectId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewIssueResponse(rsp)
}

// GetIssueWithResponse request returning *GetIssueResponse
func (c *ClientWithResponses) GetIssueWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*GetIssueResponse, error) {
	rsp, err := c.GetIssue(ctx, projectId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIssueResponse(rsp)
}

// UpdateIssueWithResponse request returning *UpdateIssueResponse
func (c *ClientWithResponses) UpdateIssueWithResponse(ctx context.Context, projectId string, id string, reqEditors ...RequestEditorFn) (*UpdateIssueResponse, error) {
	rsp, err := c.UpdateIssue(ctx, projectId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIssueResponse(rsp)
}

// CommentsWithResponse request returning *CommentsResponse
func (c *ClientWithResponses) CommentsWithResponse(ctx context.Context, projectId string, issueId string, params *CommentsParams, reqEditors ...RequestEditorFn) (*CommentsResponse, error) {
	rsp, err := c.Comments(ctx, projectId, issueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommentsResponse(rsp)
}

// NewCommentWithBodyWithResponse request with arbitrary body returning *NewCommentResponse
func (c *ClientWithResponses) NewCommentWithBodyWithResponse(ctx context.Context, projectId string, issueId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NewCommentResponse, error) {
	rsp, err := c.NewCommentWithBody(ctx, projectId, issueId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewCommentResponse(rsp)
}

func (c *ClientWithResponses) NewCommentWithResponse(ctx context.Context, projectId string, issueId string, body NewCommentJSONRequestBody, reqEditors ...RequestEditorFn) (*NewCommentResponse, error) {
	rsp, err := c.NewComment(ctx, projectId, issueId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNewCommentResponse(rsp)
}

// UpdateCommentWithResponse request returning *UpdateCommentResponse
func (c *ClientWithResponses) UpdateCommentWithResponse(ctx context.Context, projectId string, issueId string, id string, reqEditors ...RequestEditorFn) (*UpdateCommentResponse, error) {
	rsp, err := c.UpdateComment(ctx, projectId, issueId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCommentResponse(rsp)
}

// UsersWithResponse request returning *UsersResponse
func (c *ClientWithResponses) UsersWithResponse(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*UsersResponse, error) {
	rsp, err := c.Users(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ParseCustomersResponse parses an HTTP response from a CustomersWithResponse call
func ParseCustomersResponse(rsp *http.Response) (*CustomersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomersPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewCustomerResponse parses an HTTP response from a NewCustomerWithResponse call
func ParseNewCustomerResponse(rsp *http.Response) (*NewCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomerResponse parses an HTTP response from a UpdateCustomerWithResponse call
func ParseUpdateCustomerResponse(rsp *http.Response) (*UpdateCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Customer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseProjectsResponse parses an HTTP response from a ProjectsWithResponse call
func ParseProjectsResponse(rsp *http.Response) (*ProjectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewProjectResponse parses an HTTP response from a NewProjectWithResponse call
func ParseNewProjectResponse(rsp *http.Response) (*NewProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseUpdateProjectResponse(rsp *http.Response) (*UpdateProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseIssuesResponse parses an HTTP response from a IssuesWithResponse call
func ParseIssuesResponse(rsp *http.Response) (*IssuesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IssuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssuesPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewIssueResponse parses an HTTP response from a NewIssueWithResponse call
func ParseNewIssueResponse(rsp *http.Response) (*NewIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetIssueResponse parses an HTTP response from a GetIssueWithResponse call
func ParseGetIssueResponse(rsp *http.Response) (*GetIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Issue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateIssueResponse parses an HTTP response from a UpdateIssueWithResponse call
func ParseUpdateIssueResponse(rsp *http.Response) (*UpdateIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatedIssue
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCommentsResponse parses an HTTP response from a CommentsWithResponse call
func ParseCommentsResponse(rsp *http.Response) (*CommentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []CommentsPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNewCommentResponse parses an HTTP response from a NewCommentWithResponse call
func ParseNewCommentResponse(rsp *http.Response) (*NewCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NewCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUpdateCommentResponse parses an HTTP response from a UpdateCommentWithResponse call
func ParseUpdateCommentResponse(rsp *http.Response) (*UpdateCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdatedComment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersResponse parses an HTTP response from a UsersWithResponse call
func ParseUsersResponse(rsp *http.Response) (*UsersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersPage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of customers.
	// (GET /customers)
	Customers(ctx echo.Context, params CustomersParams) error
	// Create a customer.
	// (POST /customers)
	NewCustomer(ctx echo.Context) error

	// (GET /customers/{id})
	GetCustomer(ctx echo.Context, id string) error
	// Update a customer.
	// (PUT /customers/{id})
	UpdateCustomer(ctx echo.Context, id string) error
	// Get a list of projects.
	// (GET /projects)
	Projects(ctx echo.Context, params ProjectsParams) error
	// Create a project.
	// (POST /projects)
	NewProject(ctx echo.Context) error
	// Get a project.
	// (GET /projects/{id})
	GetProject(ctx echo.Context, id string) error
	// Update a project.
	// (PUT /projects/{id})
	UpdateProject(ctx echo.Context, id string) error
	// Get a list of issues.
	// (GET /projects/{project_id}/issues)
	Issues(ctx echo.Context, projectId string, params IssuesParams) error
	// Create a issue.
	// (POST /projects/{project_id}/issues)
	NewIssue(ctx echo.Context, projectId string) error

	// (GET /projects/{project_id}/issues/{id})
	GetIssue(ctx echo.Context, projectId string, id string) error

	// (PUT /projects/{project_id}/issues/{id})
	UpdateIssue(ctx echo.Context, projectId string, id string) error
	// Get a list of Comments.
	// (GET /projects/{project_id}/issues/{issue_id}/comments)
	Comments(ctx echo.Context, projectId string, issueId string, params CommentsParams) error
	// Create a comment on a issue.
	// (POST /projects/{project_id}/issues/{issue_id}/comments)
	NewComment(ctx echo.Context, projectId string, issueId string) error

	// (PUT /projects/{project_id}/issues/{issue_id}/comments/{id})
	UpdateComment(ctx echo.Context, projectId string, issueId string, id string) error
	// Get a list of users.
	// (GET /users)
	Users(ctx echo.Context, params UsersParams) error

	// (GET /users/{id})
	GetUser(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Customers converts echo context to params.
func (w *ServerInterfaceWrapper) Customers(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"exitus/customer.read", "exitus/customer.admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Customers(ctx, params)
	return err
}

// NewCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) NewCustomer(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"exitus/customer.write", "exitus/customer.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewCustomer(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/customer.read", "exitus/customer.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomer(ctx, id)
	return err
}

// UpdateCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/customer.write", "customers.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomer(ctx, id)
	return err
}

// Projects converts echo context to params.
func (w *ServerInterfaceWrapper) Projects(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"exitus/project.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProjectsParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Projects(ctx, params)
	return err
}

// NewProject converts echo context to params.
func (w *ServerInterfaceWrapper) NewProject(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"exitus/project.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewProject(ctx)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/project.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProject(ctx, id)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/project.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProject(ctx, id)
	return err
}

// Issues converts echo context to params.
func (w *ServerInterfaceWrapper) Issues(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/issue.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params IssuesParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Issues(ctx, projectId, params)
	return err
}

// NewIssue converts echo context to params.
func (w *ServerInterfaceWrapper) NewIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/issue.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewIssue(ctx, projectId)
	return err
}

// GetIssue converts echo context to params.
func (w *ServerInterfaceWrapper) GetIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/issue.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIssue(ctx, projectId, id)
	return err
}

// UpdateIssue converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/issue.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateIssue(ctx, projectId, id)
	return err
}

// Comments converts echo context to params.
func (w *ServerInterfaceWrapper) Comments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/comment.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommentsParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comments(ctx, projectId, issueId, params)
	return err
}

// NewComment converts echo context to params.
func (w *ServerInterfaceWrapper) NewComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/comment.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewComment(ctx, projectId, issueId)
	return err
}

// UpdateComment converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/comment.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateComment(ctx, projectId, issueId, id)
	return err
}

// Users converts echo context to params.
func (w *ServerInterfaceWrapper) Users(ctx echo.Context) error {
	var err error

	ctx.Set(OpenIdScopes, []string{"exitus/user.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersParams
	// ------------- Optional query parameter "q" -------------

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Users(ctx, params)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OpenIdScopes, []string{"exitus/user.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/customers", wrapper.Customers)
	router.POST(baseURL+"/customers", wrapper.NewCustomer)
	router.GET(baseURL+"/customers/:id", wrapper.GetCustomer)
	router.PUT(baseURL+"/customers/:id", wrapper.UpdateCustomer)
	router.GET(baseURL+"/projects", wrapper.Projects)
	router.POST(baseURL+"/projects", wrapper.NewProject)
	router.GET(baseURL+"/projects/:id", wrapper.GetProject)
	router.PUT(baseURL+"/projects/:id", wrapper.UpdateProject)
	router.GET(baseURL+"/projects/:project_id/issues", wrapper.Issues)
	router.POST(baseURL+"/projects/:project_id/issues", wrapper.NewIssue)
	router.GET(baseURL+"/projects/:project_id/issues/:id", wrapper.GetIssue)
	router.PUT(baseURL+"/projects/:project_id/issues/:id", wrapper.UpdateIssue)
	router.GET(baseURL+"/projects/:project_id/issues/:issue_id/comments", wrapper.Comments)
	router.POST(baseURL+"/projects/:project_id/issues/:issue_id/comments", wrapper.NewComment)
	router.PUT(baseURL+"/projects/:project_id/issues/:issue_id/comments/:id", wrapper.UpdateComment)
	router.GET(baseURL+"/users", wrapper.Users)
	router.GET(baseURL+"/users/:id", wrapper.GetUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RbbXPbuBH+Kxi0M21nGMnJ5a6tPp3ju6a5tol7TtpeU88NTK4kJCTBAKBtNaP/foM3",
	"EhRBipQYT3T5ZEsEFot9efbhAvqIY5YVLIdcCrz4iAvCSQYSuP6U0oxK9U8CIua0kJTleIHfCEiQZEgU",
	"ENPlBsk1oIzc06zMUF5mN8ARWyIOMeOJQHdrGq8R4YA4yJLnkCCa6zk53EtUkBXMcISpkvyhBL7BEc5J",
	"Bnhh14+wiNeQEaPIkpSpxIuvzyK8ZDwjEi8wzeU3T3GE5aYA8xFWwPF2G2G2XAro2QOHDyUI2dRHKUhQ",
	"SoVErABO1JwuHe0CQSUH6vihWz29GLrZILXaGLU+hDXCtQZCcpqv8FZpYEZqn1+wLIM8YDH7AHEQBcuF",
	"dlrBlSKSgp5KSrlmXP33Ww5LvMC/mdfRNbdrzN8Ite0IxyyXwYVerwHZh4gIwWJKJCTojsq1dpNVZNbe",
	"SoRjDmrwz6RDrqQZCEmywpeE7ohAdqaSWvksIRIeqSmhpWjSbSOaQC7pkgJX8uCeZEWqZp89fvLV06+/",
	"+eOf/nz+7OK77//y/K8//O0fLy//+ePV63/9+z8//Te0TlkkB24pJUIiO33ovrYRVilBOSR48VZtMnJ+",
	"rV3WsHNDw+tKILt5B7FUG7AqiUuygk6TCZN43cEV23HqfyohE/vizAXytlKJcE42rS1Wgq+VrqWQLAMe",
	"0NM+6VNxVPDFTqAXfYODryF8d61z5H1WUOwvF5lEEiwDdEPi9yvOyjyZDY5wp/WUIZ6SG0hFe7G/6+8V",
	"CNBVbgCR5EitKzca+FwctCQ2Pe5QMeQUDaw7Nmru6CXcoSoujk7Qhtv9DD0iQfXuKjOOzE6rT1d6OnX3",
	"pacTMzw/nUn3JmglWmXoCyHKgJ76677aZGIIBlcnImHF+KajPNmnLnD06s2ouSlXwQLlwdgA9DJeOaZa",
	"atUiRPKNl+4RYhwlIAlNBXK2Vum1hrRQVmTpLSA6RY01jjkE40LwY6SdFvZwKBiXMJgYCbgFTmVH6Lmn",
	"PaEXcyppTNLQdoUksgMJ9aMesayAPCiyNGASqEP2UY/QyxSIALSk93oEcM4mANk66CZCWLdHZ0DPSx5W",
	"HAjBWtsO/DU72QO+VAsYjLwGQvfBrhWqMPcl3HW+FujqWL0a6JepEHk7EL3iTq7fYnFmBaduJ4/zq3m3",
	"wg/Cr06Z9uyYv8lArBM6SrUSTG257oqXzup7flTtPTAK6eQ19NO7vruKnB9dQwYDvjbcAXi/E101+tZv",
	"oL34awPwkrOwoioE7cMpMaAwIk8QAqzmbQRwJhwPAJ3Grw0/zYu0k/cw79HjfRzisU7nX+Nb9OXoWBpL",
	"73yPfwav0FadDgbnlN3D4WxcDWdxzpr7eFwlWCXlG7MTj82RNH21xIu3/Yt5DHAbfdxR/Ra4sAk0pN3t",
	"K+emXm+vo90WuFa1zS29XXgkb/g26rbDw+6jxTnrjVREafAuHIV/0C3skLZafw/qB++gDt8H3UOr6qtd",
	"iNCLgvp2shqlhR10zAAZoWl7ie/V1w5xlfQm3L5j63yWMPjWfjWLWTa0NmldpyxM4bLx0isZ7Q38wNY5",
	"+o7B8cWiMv1UxyHGI1XJGFMplC4dZUKruadGlGJMg9X1k3qrgxF5rQ8BIS4Vo75S882Cr85LuX6iMzFl",
	"d94hH/2/Pn28YAm0vnzDU7zAaykLsZjPvQCcMzVu7gbrLkrMCtugTTJ9jvmck1wKROIYhNBcRT2oDzxV",
	"ceZAknqo+mTH4wjfcSqhfqg/uqfKGOw97NVQD9Kmch4k2g76rJTmS+Z6GsSAns1RnBH+/ts7li5hRpMZ",
	"Kevj2CvJOKDzyxcqRhqrmzbLzJs1JwVtcVP8ek2FEoAgJzcpCMQJFTRfRa5HQvMVInmCbpn+l+XIiv5f",
	"rogNjSEX2llWpYsLdC4lpzelWuHR1ZpwOE/pe0BPZ2fo9xcX6NlPj67O1ac/DNHaraCsBjwTr5ZXwG9p",
	"DP3T9FiVeFTqxDfNMGuqqhTgx7MzJZkVkCvzLPBXs7PZE5UhRK51AM0bRxCr0KH/j/oCQnWGvqw6H0Ll",
	"WhViLxLv4EPoNepbER2VrR4y/6Br2p5B9trAgJHmEoQqaA4Y9AafnJ3tdNZIUaQ01juYvxOmgNZXAIYc",
	"xdjThm0r+Co7VeCEfcTQVnlVgLbcWwz3VJai8sdMp2vU+tpkvC7VoswywjcqbUF2+UeSlfDPgzShLZgI",
	"3VXQmKzTgTuf53DX6HQ13e0zQ4OQIOQzlmwmM3KDezZhWPISti3/Pp7cv32udczkIA8b0B3oYuechjcC",
	"zt1GXk7PP9JkuyexhScT3RABiUZB+TuxQ2earn8O0nP9Tq7vdOMrMX50qiq1BBmv3V0chUk19mvS0HS2",
	"fzdnl3E8RKL3BkIdABF+eva0o13qRicMBMqZRHBPhRSzaYEhnPNl6EKX4feNlO9OdzP6eLcbvjed36eH",
	"nd135c8ReixrPgp66lIRBB0XHkNAx2/FDOMRbkY70Fxv6AtgEY02WMDdzkhj3Oz60hopeqmC7wLnV/vd",
	"AUTB64e3eELdxvxENKFqjTxsqjaWDbruEI7gLGnytIsKePZuO8/PyaE8wGk8igbUnh1RDtxKJ0MCBvh5",
	"0gzt9e2Iat6Zk2bwsc47mVL++cLDAXW8Fx6qoj0CHux/P9NkO6/vxQwr47Y90Qow05M4KLLC8VQrOSqu",
	"ol8ha/AuPwUiy3hkTEDpGQP4Qu1rF1HmssJ4rkDd7YkWU3hhrz8cBkim2Nb3KGaTxtL1J6Mv9mzqYdHJ",
	"WzQQQYcQF2PzftpS+WU3hvZh0lAaY7QfRWIOD7qpsapvSbOxk+FMe8LrCHwKoE8vIRodEmbmiUXF1GTs",
	"E4VF4/x+uujwQOcAYFF/9Tf+bw324EzVcLdTAuchTtjJxJDek7+hUCxZY30RNGzMz+aqH57snB63m3ju",
	"93tjmnf2Vvd+lnbhua/q1tmLSAcc/9S3ydunP1bqyYQ3kZLErVvyU8X4p6OH1T2yB25E+8sGQ/igEzBr",
	"+X6a6BZgeYgz1vF8CLhXTLKHNghPh7HE4eTyoo9QHoj2vadB1q4nR1oGJMRxiRCO7+oO07CWjB4eiE3x",
	"ZdzMqC+MBdykbTPGSWrCgKJb2dx5UH3hu2/o26sa7AFO/3urvq42CmW0+JN5hTTX8cJePMKJuz4afnJq",
	"zkmjoafyO3c8Gn3/KNzOjQIvvVHoVScKMsMoDC5RVzgDvw2HzSVnSRnrX3GYQa37bKSgs8DltNvHeHu9",
	"/SUAAP//GmpRGCVHAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
